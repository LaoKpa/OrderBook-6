package baoying.orderbook.testtool.qfj;

import baoying.orderbook.app.MatchingEngineApp;
import baoying.orderbook.app.MatchingEngineFIXWrapper;
import baoying.orderbook.app.UniqIDGenerator;
import baoying.orderbook.testtool.FIXMessageUtil;
import baoying.orderbook.testtool.ScheduleBatchConfig;
import baoying.orderbook.testtool.TestToolArgs;
import baoying.orderbook.testtool.TestToolUtil;
import com.beust.jcommander.JCommander;
import com.google.common.base.Charsets;
import com.google.common.io.CharStreams;
import io.vertx.core.Vertx;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import quickfix.*;

import java.io.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

//This is a simplified version.   
//For production code, please read common.DefaultQFJSingleSessionInitiator.
public class FirstQFJClientBatch {

    private final static Logger log = LoggerFactory.getLogger(FirstQFJClientBatch.class);

    private final Vertx _vertx = Vertx.vertx();

    private Instant start = null;
    private final AtomicInteger totalSent = new AtomicInteger(0);
    private final AtomicInteger totalRecv = new AtomicInteger(0);


    private final ExecutorService _fixLatencyERResult = Executors.newFixedThreadPool(2,new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            return new Thread(r, "Thread - testtool processes Latency ER result");
        }
    });

    private final ExecutorService _fixSendingBatchOrder = Executors.newFixedThreadPool(16,new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            return new Thread(r, "Thread - testtool sending batch Order");
        }
    });

    final TestToolArgs _testToolArgs;
    private String _latencyDataFile ;
    private final int bufferSize = 10*1024*1024;
    private final BufferedOutputStream output;


    String  getQFJConfigContent(List<String> clientCompIDs)throws Exception{

        //https://stackoverflow.com/questions/309424/read-convert-an-inputstream-to-a-string
        String qfjConfigBaseContent = CharStreams.toString(
                new InputStreamReader(
                        FirstQFJClientBatch.class.getClassLoader().getResourceAsStream("testtool/FirstQFJClient.qfj.config_base.txt"), Charsets.UTF_8));

        StringBuilder clientSessions = new StringBuilder("#====autoGeneratedSessions====");
        for(String c: clientCompIDs){
            clientSessions.append("\n")
                    .append("[session]").append("\n")
                    .append("SenderCompID=").append(c).append("\n");
        }
        return qfjConfigBaseContent+clientSessions;
    }

    FirstQFJClientBatch(TestToolArgs testToolArgs) throws Exception{

        _testToolArgs = testToolArgs;
        _latencyDataFile = "log/e2e_"+testToolArgs.clientCompIDPrefix+".csv";
        output = TestToolUtil.setupOutputLatencyFile(_latencyDataFile, bufferSize);

    }



    public void execute() throws  Exception{

        start = Instant.now();

        List<String> clientIDs = new ArrayList<>();
        List<SessionID> clientSessionIDs = new ArrayList<>();
        {
            IntStream.range(0, _testToolArgs.numOfClients).forEach(
                    it -> {
                        //you cannot use prefix+index, because it will conflict  while multi clients up with same prefix
                        String clientEntityID = _testToolArgs.clientCompIDPrefix +"_"+UniqIDGenerator.next();
                        clientIDs.add(clientEntityID);

                        SessionID sessionID =  new SessionID("FIXT.1.1", clientEntityID, MatchingEngineFIXWrapper.serverCompID, "");
                        clientSessionIDs.add(sessionID);

                    }
            );
        }

        AtomicInteger completedInCurrentPeriodCounter = new AtomicInteger(0);

        final AtomicInteger connectedClients = new AtomicInteger(0);

        ScheduleBatchConfig sender = new ScheduleBatchConfig();
        ScheduleBatchConfig.Config batchConfig = sender.getBatchConfig(_testToolArgs.ratePerMinute);
        log.info("testtool - {} - schedule config:{}",_testToolArgs.clientCompIDPrefix, batchConfig);
        Application application = new FirstMessageCallback(){
            @Override
            public void fromApp(Message msg, SessionID sessionID) {
                try {
                    if(!msg.getHeader().getString(35).equals("8")){
                        return;
                    }
                    long erTimeNano = System.nanoTime();

                    totalRecv.incrementAndGet();
                    int completedInCurrentPeriod = completedInCurrentPeriodCounter.incrementAndGet();

                    //TODO add SOH in the index
                    if(msg.getHeader().getString(56).indexOf(MatchingEngineApp.LATENCY_ENTITY_PREFIX) ==0){

                        String latencyRecord= TestToolUtil.getLantecyRecord(msg,erTimeNano);
                        if(latencyRecord.length() < 1){
                            log.error("fail to get latency record from:{}", msg.toString());
                            return;
                        }
                        _fixLatencyERResult.submit(()->{
                            try {
                                output.write(latencyRecord.getBytes());
                            } catch (Exception e) {
                                log.error("",e);
                            }
                        });
                    }

                    if(completedInCurrentPeriod < batchConfig._msgNumPerPeriod) {
                        int nextClientCompIDIndex = totalSent.get() % _testToolArgs.numOfClients;
                        String nextClientCompID = clientIDs.get(nextClientCompIDIndex);
                        SessionID nextClientSessionID = clientSessionIDs.get(nextClientCompIDIndex);

                        Message order = buildOrder(nextClientCompID);
                        _fixSendingBatchOrder.submit(()->{
                            try {
                                Session.sendToTarget(order, nextClientSessionID);
                            }catch (Exception e){
                                log.error("fail to send order to target:"+nextClientSessionID.toString(), e);
                            }
                        });


                        totalSent.incrementAndGet();
                    }else{
                        completedInCurrentPeriodCounter.set(0);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }

            }

            @Override
            public void onLogon(SessionID paramSessionID) {
                log.info("{} - onLogon session : {} ", _testToolArgs.clientCompIDPrefix, paramSessionID);
                connectedClients.incrementAndGet();
                log.info("{} - ready session number : {} ", _testToolArgs.clientCompIDPrefix, connectedClients.get());

            }
        };

        String qfjConfigContent = getQFJConfigContent(clientIDs);
        SessionSettings settings = new SessionSettings(new ByteArrayInputStream(qfjConfigContent.getBytes())) ;
        MessageStoreFactory storeFactory = new FileStoreFactory(settings);
        LogFactory logFactory = new SLF4JLogFactory(settings);
        MessageFactory messageFactory = new DefaultMessageFactory();

        ThreadedSocketInitiator initiator = new ThreadedSocketInitiator(application, storeFactory, settings, logFactory,messageFactory);
        initiator.start();

        while(true){
            if(connectedClients.get() < clientIDs.size()){
                log.info("testtool - {} - wait all connections ready, expect:{}, now:{}", _testToolArgs.clientCompIDPrefix, clientIDs.size(), connectedClients.get());
                TimeUnit.SECONDS.sleep(3);
            }else{
                break;
            }
        }
        TimeUnit.SECONDS.sleep(3);
        log.info("{} all connections ready", _testToolArgs.clientCompIDPrefix);

        //the schedule is to trigger the first order of each period
        Runnable command = ()-> {
            try {
                int nextClientCompIDIndex = totalSent.get() % _testToolArgs.numOfClients;
                String nextClientCompID = clientIDs.get(nextClientCompIDIndex);
                SessionID nextClientSessionID = clientSessionIDs.get(nextClientCompIDIndex);

                Message order = buildOrder(nextClientCompID);
                Session.sendToTarget(order, nextClientSessionID);

                totalSent.incrementAndGet();
            } catch (Exception e) {
                log.error("exception while sending",e);
            }
        };
        long initialDelay = 0;
        ScheduledExecutorService executorFor1stOrderOfEachPeriod = Executors.newSingleThreadScheduledExecutor();
        executorFor1stOrderOfEachPeriod.scheduleAtFixedRate( command,  initialDelay, batchConfig._period,  batchConfig._unit);


        start = Instant.now();
        _vertx.setPeriodic(30 * 1000, (v)->{
            double sendRateInSecond = TestToolUtil.getCurrentRateInSecond(start, totalSent);
            log.warn("{} - totalSent:{}, rotalRecv:{}, sendRateInSecond:{}", _testToolArgs.clientCompIDPrefix, totalSent, totalRecv, String.format("%.2f", sendRateInSecond));
        });

    }

    Message buildOrder(String clientCompID) throws Exception{

        String clientOrdID = clientCompID+ UniqIDGenerator.next();

        Message order;
        if(clientCompID.startsWith(MatchingEngineApp.LATENCY_ENTITY_PREFIX)){
            order = FIXMessageUtil.buildNewOrderSingleWithLatencyTimestamp(clientCompID,
                    clientOrdID,
                    _testToolArgs.symbol,
                    _testToolArgs.px,
                    _testToolArgs.qty,
                    _testToolArgs.orderType,
                    _testToolArgs.side);
        }else{
            order = FIXMessageUtil.buildNewOrderSingle(clientCompID,
                    clientOrdID,
                    _testToolArgs.symbol,
                    _testToolArgs.px,
                    _testToolArgs.qty,
                    _testToolArgs.orderType,
                    _testToolArgs.side);
        }

        return order;
    }

    void stop() throws Exception{
        output.flush();
        output.close();
    }


    public static void main(String[] args) throws Exception {

        TestToolArgs testToolArgsO = new TestToolArgs();
        JCommander.newBuilder()
                .addObject(testToolArgsO)
                .build()
                .parse(args);

        FirstQFJClientBatch firstQFJClientBatch = new FirstQFJClientBatch(testToolArgsO);

        firstQFJClientBatch.execute();

        TimeUnit.SECONDS.sleep(testToolArgsO.durationInSecond);

        firstQFJClientBatch.stop();
        log.info("exiting, since reached duration limit:"+ testToolArgsO.durationInSecond+" seconds");

        System.exit(0);
    }
}
