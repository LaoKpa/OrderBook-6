package baoying.orderbook.testtool.qfj;

import baoying.orderbook.app.MatchingEngineFIXWrapper;
import baoying.orderbook.app.UniqIDGenerator;
import baoying.orderbook.testtool.ScheduleSender;
import baoying.orderbook.testtool.TestToolArgs;
import com.beust.jcommander.JCommander;
import com.beust.jcommander.Parameter;
import com.google.common.base.Charsets;
import com.google.common.io.CharStreams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import quickfix.*;

import java.io.ByteArrayInputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

//This is a simplified version.   
//For production code, please read common.DefaultQFJSingleSessionInitiator.
public class FirstQFJClientBatch {

    private final static Logger log = LoggerFactory.getLogger(FirstQFJClientBatch.class);

    String  getQFJConfigContent(List<String> clientCompIDs)throws Exception{

        //https://stackoverflow.com/questions/309424/read-convert-an-inputstream-to-a-string
        String qfjConfigBaseContent = CharStreams.toString(
                new InputStreamReader(
                        FirstQFJClientBatch.class.getClassLoader().getResourceAsStream("testtool/FirstQFJClient.qfj.config_base.txt"), Charsets.UTF_8));

        StringBuilder clientSessions = new StringBuilder("#====autoGeneratedSessions====");
        for(String c: clientCompIDs){
            clientSessions.append("\n")
                    .append("[session]").append("\n")
                    .append("SenderCompID=").append(c).append("\n");
        }
        return qfjConfigBaseContent+clientSessions;
    }

    public void execute( String symbol,
                            String price,
                            String qty ,
                            String ordType,
                            String side,

                            String clientCompIDPrefix,
                            int fixClientNum,
                            int ratePerMinute  ) throws  Exception{


        List<String> clientIDs = new ArrayList<>();
        {
            IntStream.range(0, fixClientNum).forEach(it -> clientIDs.add(clientCompIDPrefix + String.valueOf(it)));
        }
        String qfjConfigContent = getQFJConfigContent(clientIDs);
        final Application application;
        {
            if(clientCompIDPrefix.startsWith(MatchingEngineFIXWrapper.LATENCY_ENTITY_PREFIX)){
                application= new LatencyMessageCallback();
            }else{
                application= new FirstMessageCallback();
            }

        }
        SessionSettings settings = new SessionSettings(new ByteArrayInputStream(qfjConfigContent.getBytes())) ;
        MessageStoreFactory storeFactory = new FileStoreFactory(settings);
        LogFactory logFactory = new SLF4JLogFactory(settings);
        MessageFactory messageFactory = new DefaultMessageFactory();

        //multi-thread is used, for better performance to consume messages on high load, e.g. 500 order/second
        ThreadedSocketInitiator initiator = new ThreadedSocketInitiator(application, storeFactory, settings, logFactory,messageFactory);

        initiator.start();

        // after start, you have to wait several seconds before sending
        // messages.
        // in production code, you should check the response Logon message.
        // Refer: DefaultQFJSingSessionInitiator.java
        TimeUnit.SECONDS.sleep(3);

        AtomicInteger totalSent = new AtomicInteger(0);
        ScheduleSender s = new ScheduleSender();
        s.execut(ratePerMinute, ()-> {
                int nextClientCompIDIndex = totalSent.get() % fixClientNum;
                String clientCompID = clientIDs.get(nextClientCompIDIndex);

                SessionID sessionID = new SessionID("FIXT.1.1", clientCompID, MatchingEngineFIXWrapper.serverCompID, "");
                if (!Session.doesSessionExist(sessionID)) {
                    log.warn("ignore the realtime ER to client, since he:{} is not online now", clientCompID);
                    return;
                }

                String clientOrdID = clientCompID+ UniqIDGenerator.next();
                try {
                    Message order = FIXOrderBuilder.buildNewOrderSingle(clientOrdID,
                            symbol,
                            price,
                            qty,
                            ordType,
                            side);
                    Session.sendToTarget(order, sessionID);
                } catch (Exception e) {
                    log.error("exception while sending",e);
                }

                int sent = totalSent.incrementAndGet();
                if (sent >= Integer.MAX_VALUE / 2) {
                    totalSent.getAndSet(0);
                }
        });



    }


    public static void main(String[] args) throws Exception {

        TestToolArgs testToolArgsO = new TestToolArgs();
        JCommander.newBuilder()
                .addObject(testToolArgsO)
                .build()
                .parse(args);
        String symbol = testToolArgsO.symbol;
        String price = testToolArgsO.px;
        String qty = testToolArgsO.qty;
        String ordType = testToolArgsO.orderType; //Market or Limit
        String side = testToolArgsO.side;//Bid or Offer

        String clientCompIDPrefix = testToolArgsO.clientCompIDPrefix + System.currentTimeMillis() + "_";
        int fixClientNum = testToolArgsO.numOfClients;
        int ratePerMinute = testToolArgsO.ratePerMinute;

        FirstQFJClientBatch firstQFJClientBatch = new FirstQFJClientBatch();

        firstQFJClientBatch.execute( symbol,price,qty ,ordType, side   ,clientCompIDPrefix  ,fixClientNum,ratePerMinute);

        TimeUnit.SECONDS.sleep(testToolArgsO.durationInSecond);
        log.info("exiting, since time out:"+ testToolArgsO.durationInSecond+" seconds");
        System.exit(0);
    }
}
